\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{listings}
%\usepackage{xgreek}

% Greek fonts
\RequirePackage[cm-default]{fontspec}
\defaultfontfeatures{Mapping=tex-text}
  % you may want to try: {FreeSerif} or {Times New Roman}
\setmainfont{Ubuntu}
  % you may want to try: {FreeSans} or {Arial}
\setsansfont[Scale=MatchLowercase]{FreeMono}
  % you may want to try: {FreeMono} or {Courier New}
\setmonofont[Scale=MatchLowercase]{Liberation Mono}
\newcommand\ntext[1]{\ensuremath{\mathsf{#1}}}

\begin{document}

\lstset{language=Matlab,
        numbers=left, numberstyle=\tiny,
        basicstyle=\ttfamily\footnotesize,
        keywordstyle=\bfseries,
        %basewidth=0.51em,
        xleftmargin=10pt,
        showspaces=false,
        breaklines,
        showstringspaces=false,
        breakatwhitespace=true,
        captionpos=b,
        breakindent=34.25ex,
        belowskip=5pt,
        escapeinside={@}{@}
        }

\section{Κανονική Μορφή}

Για να υπολογίσουμε την Garside κανονική μορφή ενός στοιχείου $ b=s_1s_2\dots s_n \in B_n$
χρειαζόμαστε για κάθε permutation να υπολογίσουμε το αρχικό και το τελικό τμήμα.
Επιπλέον η κανονική μορφή έχει την μορφή $\Delta^{-n}p_1\dots p_k$, όπου $ p_i $ permutations. Για να μπορούμε να κάνουμε πράξεις μεταξύ στοιχείων αντιστοιχίζουμε αναναριστούμε το στοιχείο $ D_n$ με 
το Braid $ (s_1\dots s_n)(s_1\dots s_{n-1}) \dots s_1 $ και κάθε $ p_i $ με ένα μοναδικό braid. 
Για να μπορέσουμε να αντιστοιχίσουμε κάθε permutation με ένα μοναδικό braid καθώς και για να αποφύγουμε τον πολλαπλό υπολογισμό τβων αρχικών και τελικών τμημάτων χρησιμοποιούμε τον πίνακα \ntext{prmdata} στον οποίο οι πληροφορίες αυτές υπάρχουν.


Ο υπολογισμός της Garside κανονικής μορφής γίνεται από την συνάρτηση \ntext{normalform(n,b,prmdata)} που δέχεται σαν ορίσματα την παράμετρο \ntext{n}, μια αναπαράσταση \ntext{b} του στοιχείου της $ B_n $ και τον τον πίνακα \ntext{prmdata}.
Η συνάρτηση αυτή αρχικά βρήσκει τον εκθέτη \ntext{ndelta} του $ \Delta $ και το θετικό τμήμα \ntext{pos} του braid. Έπειτα, παράγει την αριστερή κανονική μορφή των permutations καλώντας την \ntext{leftnormal} και αναιρεί τις αρχικές εμφανίσεις του permutation [4 3 2 1] με τους εκθέτες του $ \Delta $. Τελικά, αντικαθιστά τον $ \Delta^{-\ntext{ndelta}} $ και κάθε permutation με τα αντίστοιχα στοιχεία του $ B_n $
\begin{lstlisting}
function [nf] = normalform(n,b,prmdata)

nf=[];
[pos,ndelta] = deltapos(n,b);
perm = left_normal(n,permutations(n,pos), prmdata);

while(perm(1,:)==[4 3 2 1])
    perm(1,:)=[];
    ndelta=ndelta+1;
end
d=inverse(delta(n));
for i=1:ndelta
    nf = [nf d];
end
[s,c]=size(perm);
for i = 1:s
    nf = [nf prmdata(permutation_number(n,perm(i,:))).braid];
end
\end{lstlisting}

Σαν παράδειγμα παραθέτουμε τον υπολογισμό της κανονικής μορφής του $ s_1s_3^{-1}s_2 $:
\begin{lstlisting}
>> normalform(n,[1 -3 2],prmdata)
pos =

     3     3     2     1     3     2     2
ndelta =

     1
perm =

     4     3     1     2
     2     3     1     4
nf =

    -1    -2    -1    -3    -2    -1     2     1     3     2     1     1     2
\end{lstlisting}

\section{Ko \textit{et al.} protocol}

Το αρχείο cryptosystem.m υλοποιεί το προτόκολο των Ko \textit{et al.}. Αρχικά ανοίγει το αρχείο dataN3.mat για να πάρει την παράμετρο $ n $ και τον κατάλληλο πίνακα δεδομένων. Με τον τρόπο αυτό το σύστημα παραμετροποιείται έτσι ώστε να λειτουργεί για διάφορα $ n $.

Έπειτα καθορίζονται οι παράμετροι του συστήματος, όπως το $ L $, το επιθυμητό μέγεθος των μηκών των στοιχείων $ a,b,g $, τα οποία παράγονται τυχαία και η σημαία των σχημάτων \ntext{dflag}, η οποία όταν τεθεί σε 1 εμφανίζει σχηματικά όλα τα braids που παράγονται κατα την διάρκεια του υπολογισμού. 
Τελικά γίνεται η κρυπτογράφιση και η αποκρυπτογράφιση, καλώντας τις αντίστοιχες συναρτήσεις. Παρατηρούμε ότι τα ορίσματα που δίνονται στις συναρτήσεις αποκρυπτογράφησεις συμφωνούν με τις προδιαγραφές του συστήματος, δηλαδή, η συνάρτηση αποκρυπτογράφησης της Alice δέχεται σαν όρισμα το κρυφό κλειδί της Alice, \ntext{a}, η συνάρτηση αποκρυπτογράφησης του Bob δέχεται σαν όρισμα το κρυφό κλειδί του Bob, \ntext{b}, ενώ η συνάρτηση αποκρυπτογράφισης της Eve δέχεται σαν ορίσματα μόνο τα δημοσίως γνωστά δεδομένα.  
\begin{lstlisting}
%%data
s=open('dataN3.mat');
data=s.dataN3;

%%parameters
%if dflag=1 every braid will be dispayed in figure
dflag=0;
n=data.n;
prmdata=data.data;
L=round(n/2);
gLength=3;
aLenght=5;
bLenght=4;
g = randi(n-1,1,gLength);

%%encryption
[a,aga]=AliceEncrypt(data,L,g,aLenght,dflag);
[b,bgb]=BobEncrypt(data,L,g,bLenght,dflag);
%decryption
keya = AliceDencrypt(data,a,bgb,dflag);
keyb = BobDencrypt(data,b,aga,dflag);
keye = EveDencrypt(data,aga,bgb,g,dflag);
\end{lstlisting}

\subsection{Συναρτήσεις Κρυπτογράφησης}

Οι συναρτήσεις κρυπτογράφησης της Alice και του Bob είναι παρόμοιες, για τον λόγο αυτό παραθέτουμε μόνο της Alice.

Η Alice διαλέγει τυχαία ένα κλειδί (το οποίο τροποποιείται ώστε να αποτελείται από στοιχεία $ s_i,\in \{ -(L-1),\dots,-1,1,\dots,L-1 \} $) και υπολογίζει την κανονική μορφή του στοιχείου $ a^{-1}ga $ χρησιμοποιώντας την συνάρτηση \ntext{expbraid}, ο κώδικας της οποίας ακολουθεί. Τελικά επιστρέφονται το στοιχείο αυτό και το $ a $, αφού είναι απαραίτητα για την αποκρυπτογράφιση.

\begin{lstlisting}
function [res]=expbraid(base,expon)
    res=[inverse(expon) base expon];
\end{lstlisting}

\begin{lstlisting}
function [a,aga] = AliceEncrypt(data,L,g,aLength,dflag)

n = data.n;
prmdata=data.data;

disp('Alice: chossing a...')
a = randi(n-3,1,aLength)+1;
ina = find(a>L-1);
a(ina)=a(ina)-2*L+1;

%calculating a^{-1}ga
aga = normalform(n,expbraid(g,a),prmdata);
\end{lstlisting}  

\subsubsection{Συναρτήσεις Αποκρυπτογράφησης}

Οι συναρτήσεις αποκρυπτογράφησης της Alice και του Bob είναι παρόμοιες, για τον λόγο αυτό παραθέτουμε μόνο της Alice.

Στην συνάρτηση αποκρυπτογράφησης η Alice υπολογίζει το κλειδί της ως $ k_a = a^{-1}b^{-1}gba $, όπου το $b^{-1}gb$ το δέχεται σαν όρισμα και επιστρέφει την κανονική του μορφή. Με τα νούμερα που χρησιμοποιούμε το κλειδί έχει ήδη μεγάλη έκταση, επιπλέον, το το αρχικό του τμήμα αποτελείται από κάποιο braid της μορφής $ \Delta^{-k} $, το οποίο δεν αυξάνει την πολυπλοκότητα του κλειδιού επειδή μπορεί εύκολα να αποκρυπτογραφηθεί. Για τον λόγο αυτό επιλέγουμε ως κλειδί να θεωρούμε μόνο το αρχικό τμήμα του $ k_a $.
\begin{lstlisting}
function [keya] = AliceDencrypt(data,a,bgb,dflag)
keya =  expbraid(bgb,a);
keya=normalform(data.n,keya,data.data);
keya=keya(find(keya>0));
\end{lstlisting}
\end{document}